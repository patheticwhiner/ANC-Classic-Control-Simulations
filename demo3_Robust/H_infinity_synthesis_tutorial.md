# H∞ 控制器设计教程：从问题构建到 `augw` 与 `hinfsyn` 的应用

本教程旨在阐述 H∞ 鲁棒控制的基本设计流程，重点介绍如何在 MATLAB 中使用 Robust Control Toolbox™ 的核心函数 `augw` 和 `hinfsyn` 来完成一个标准的混合灵敏度（Mixed-Sensitivity）H∞ 控制器设计。

## 1. H∞ 控制的核心思想

H∞ 控制的目标是设计一个控制器 `K`，使得在存在外部扰动 `w` 和模型不确定性的情况下，闭环系统的性能输出 `z` 能够被有效抑制。其核心是最小化从扰动 `w` 到性能输出 `z` 的闭环传递函数 `Tzw` 的 H∞ 范数（`||Tzw||∞`）。

这个 H∞ 范数代表了系统在所有频率上对输入信号的最大能量增益。我们的目标是找到一个控制器 `K`，使得这个最坏情况下的增益 `γ` 尽可能小。

## 2. 标准问题陈述：广义被控对象

为了系统化地解决这个问题，我们首先需要构建一个**广义被控对象**（Generalized Plant），通常记为 `P`。如下图所示，`P` 将所有与问题相关的部分都包含在内：被控对象 `G`、权重函数、以及它们之间的连接关系。

<img src="..\assets\mixed-sens.png" width = 50%/>

- **输入**:
  - `w`: 外部输入，包括扰动、噪声等。
  - `u`: 控制输入，由控制器 `K` 产生。
- **输出**:
  - `z`: 性能输出，是我们希望抑制的信号，例如跟踪误差。
  - `y`: 测量输出，是控制器 `K` 用来计算控制量的信号。

控制器的设计目标就变成了：找到一个控制器 `K`，使得从 `w` 到 `z` 的闭环传递函数 `Tzw` 的 H∞ 范数小于一个给定的值 `γ`（通常我们希望 `γ < 1`）。

## 3. 权重函数：定义性能需求

我们如何定义“性能好坏”呢？答案是使用**权重函数**（Weighting Functions）。通过为不同的信号（如误差、控制量）分配不同的频率权重，我们可以告诉优化算法我们关心什么。

<img src="..\assets\mixed-sens_a.png" width = 50%/>

在标准的混合灵敏度设计中，主要使用三个权重函数：

- **`W1` (或 `Ws`) - 性能权重**:
  - **作用**: 用于对灵敏度函数 `S = 1 / (1 + GK)` 进行加权。`S` 代表了从外部扰动到输出误差的传递函数。
  - **目标**: `||W1 * S||∞ < 1`。
  - **设计**: 通常是一个低通滤波器。我们希望在低频段（系统的工作频段）有很好的扰动抑制能力，所以 `W1` 在低频段的增益应该很大，迫使 `S` 在低频段的增益变得很小。

- **`W2` (或 `Wks`) - 控制努力权重**:
  - **作用**: 用于对 `K*S` 进行加权，`K*S` 是从扰动到控制器输出 `u` 的传递函数。
  - **目标**: `||W2 * K * S||∞ < 1`。
  - **设计**: 通常是一个高通滤波器或常数。它限制了控制器的输出能量，防止执行器饱和，并避免控制器在高频段过度活跃。

- **`W3` (或 `Wt`) - 鲁棒性权重**:
  - **作用**: 用于对互补灵敏度函数 `T = GK / (1 + GK)` 进行加权。`T` 与系统的鲁棒稳定性和对传感器噪声的敏感度有关。
  - **目标**: `||W3 * T||∞ < 1`。
  - **设计**: 通常是一个高通滤波器。它限制了 `T` 在高频段的增益，以保证对高频未建模动态的鲁棒性。

## 4. `augw` 函数：自动构建广义对象

手动连接被控对象 `G` 和权重函数 `W1`, `W2`, `W3` 来构建广义对象 `P` 是一个繁琐且容易出错的过程。MATLAB 的 `augw` (augment weights) 函数极大地简化了这一过程。

**语法**:
```matlab
P = augw(G, W1, W2, W3);
```

- `G`: 你的被控对象（传递函数 `tf` 或状态空间 `ss` 模型）。
- `W1`, `W2`, `W3`: 上述定义的权重函数。如果某个权重不使用，可以用一个空的 `[]` 代替。

`augw` 会自动将这些模块连接起来，生成一个符合 `hinfsyn` 输入要求的状态空间模型 `P`。

## 5. `hinfsyn` 函数：综合 H∞ 控制器

`hinfsyn` (H-infinity synthesis) 是执行核心优化计算的函数。它接收广义对象 `P`，并计算出最优的 H∞ 控制器 `K`。

**语法**:
```matlab
[K, CL, gamma] = hinfsyn(P, NMEAS, NCON);
```

- **输入**:
  - `P`: 由 `augw` 生成的广义被控对象。
  - `NMEAS`: 测量输出 `y` 的数量（即控制器 `K` 的输入数量）。对于单输入单输出（SISO）系统，`NMEAS = 1`。
  - `NCON`: 控制输入 `u` 的数量（即控制器 `K` 的输出数量）。对于 SISO 系统，`NCON = 1`。

- **输出**:
  - `K`: 计算得到的最优 H∞ 控制器。
  - `CL`: 从 `w` 到 `z` 的闭环传递函数 `Tzw`。
  - `gamma`: 最终达到的 H∞ 范数值。这是评估设计成败的关键指标。

**`gamma` 的解读**:
- `gamma < 1`: **设计成功**。这意味着所有由权重函数定义的性能/鲁棒性目标都已满足。
- `gamma >= 1`: **设计失败**。这意味着在给定的权重约束下，不存在一个稳定的控制器能够满足所有要求。此时，你需要放宽（降低）一个或多个权重函数的增益，然后重试。

## 6. 完整 MATLAB 示例

让我们通过一个完整的流程来演示如何使用这些函数。

```matlab
%% 1. 定义被控对象和权重函数
clear; clc;

% 定义一个简单的二阶被控对象 G(s)
s = tf('s');
G = 1 / (s^2 + 0.2*s + 1);

% 定义性能权重 W1 (低通滤波器)
% 要求在 0.1 rad/s 以下有-40dB的扰动抑制，在 10 rad/s 以上性能要求放宽
M = 100; % 低频增益 (40 dB)
wb = 1;  % 带宽
A = 1e-4; % 高频增益
W1 = (s/M + wb) / (s + wb*A);
W1.Name = 'W1';

% 定义鲁棒性权重 W3 (高通滤波器)
% 从 100 rad/s 开始，要求T的增益以40dB/dec的速度下降
W3 = tf([1/1.5 10],[1 1000]); % 这是一个示例，实际需要根据模型不确定性来设计
W3.Name = 'W3';

% 在这个例子中，我们不限制控制量，所以 W2 为空
W2 = [];

%% 2. 使用 augw 构建广义对象
P = augw(G, W1, W2, W3);

%% 3. 使用 hinfsyn 综合控制器
NMEAS = 1; % 1个测量输出 y
NCON = 1;  % 1个控制输入 u

[K, CL, gamma] = hinfsyn(P, NMEAS, NCON);

fprintf('H-infinity 综合完成，最终的 gamma = %.4f\n', gamma);

if gamma >= 1
    disp('警告: 设计未满足所有约束，请考虑放宽权重函数。');
else
    disp('成功: 控制器满足所有性能和鲁棒性约束。');
end

%% 4. 验证设计结果
L = G * K; % 开环传递函数
S = feedback(1, L); % 灵敏度函数
T = feedback(L, 1); % 互补灵敏度函数

figure;
% 验证性能: sigma(S) < 1/sigma(W1)
bodemag(S, 1/W1, {1e-2, 1e3});
grid on;
title('灵敏度函数 S(s) vs 性能权重 1/W1(s)');
legend('实际 S(s)', '性能边界 1/W1(s)');

figure;
% 验证鲁棒性: sigma(T) < 1/sigma(W3)
bodemag(T, 1/W3, {1e-2, 1e3});
grid on;
title('互补灵敏度函数 T(s) vs 鲁棒性权重 1/W3(s)');
legend('实际 T(s)', '鲁棒性边界 1/W3(s)');
```

### 结果分析
- **Gamma 值**: 首先检查 `gamma`。如果它小于 1，说明理论上设计是成功的。
- **Bode 图**:
  - 在第一张图中，如果红色的 `S(s)` 曲线在所有频率上都位于蓝色的 `1/W1(s)` 边界曲线之下，那么性能目标 `||W1 * S||∞ < 1` 就得到了满足。
  - 在第二张图中，如果红色的 `T(s)` 曲线在所有频率上都位于蓝色的 `1/W3(s)` 边界曲线之下，那么鲁棒性目标 `||W3 * T||∞ < 1` 就得到了满足。

## 7. 总结
`augw` 和 `hinfsyn` 的组合为 H∞ 控制器设计提供了一个强大而直接的工作流程：
1.  **定义需求**: 根据你的性能（如扰动抑制）和鲁棒性（如高频稳定性）需求，设计合适的权重函数 `W1`, `W2`, `W3`。
2.  **构建系统**: 使用 `augw` 将被控对象 `G` 和权重函数 `W` 自动组装成广义对象 `P`。
3.  **综合求解**: 将 `P` 和系统的输入输出数量传递给 `hinfsyn`，计算出最优控制器 `K` 和性能指标 `gamma`。
4.  **验证与迭代**: 检查 `gamma` 值并绘制灵敏度函数图来验证设计。如果不满足要求，返回第一步，调整权重函数，然后重复整个过程。

## 8. 理论背景：`hinfsyn` 背后的数学原理

`hinfsyn` 函数的成功应用，其背后是坚实的鲁棒控制理论。虽然完整的推导非常复杂，但我们可以理解其核心思想，即著名的 **DGKF 方法**（Doyle, Glover, Khargonekar, Francis, 1989）。该方法将 H∞ 控制问题转化为求解两个代数 Riccati 方程（Algebraic Riccati Equations, AREs）。

### 步骤 1: 问题的状态空间描述

首先，由 `augw` 生成的广义被控对象 `P` 可以表示为以下状态空间形式：

$$
P(s) = 
\begin{bmatrix} A & B_1 & B_2 \\ C_1 & D_{11} & D_{12} \\ C_2 & D_{21} & D_{22} \end{bmatrix}
=
\left[
\begin{array}{c|cc}
A & B_1 & B_2 \\
\hline
C_1 & D_{11} & D_{12} \\
C_2 & D_{21} & D_{22}
\end{array}
\right]
$$

其中：
- `x` 是系统的状态向量。
- `w` 是外部扰动输入，`u` 是控制输入。
- `z` 是性能输出，`y` 是测量输出。

关系式如下：
$$
\dot{x} = Ax + B_1w + B_2u \\
z = C_1x + D_{11}w + D_{12}u \\
y = C_2x + D_{21}w + D_{22}u
$$

控制器 `K` 也有其自己的状态空间表示 `K(s) = [Ak, Bk, Ck, Dk]`。当 `K` 与 `P` 形成闭环后，我们可以得到从 `w` 到 `z` 的闭环传递函数 `Tzw`。H∞ 控制的目标就是找到一个能稳定闭环系统的控制器 `K`，使得 `||Tzw||∞ < γ`。

### 步骤 2: 两个关键的Riccati方程

DGKF方法指出，对于给定的 `γ > 0`，能满足 `||Tzw||∞ < γ` 的控制器存在的**充分必要条件**是以下三个条件同时成立：

1.  存在一个唯一的、半正定（`X∞ >= 0`）的解 `X∞`，满足下面的**控制Riccati方程**（CARE）：
    $$
    A^\top X + XA + C_1^\top C_1 + X(\gamma^{-2}B_1 B_1^\top - B_2 B_2^\top)X = 0
    $$
    （在一些简化假设下，例如 `D12` 和 `C1` 正交）

2.  存在一个唯一的、半正定（`Y∞ >= 0`）的解 `Y∞`，满足下面的**滤波Riccati方程**（FARE）：
    $$
    AY + YA^\top + B_1 B_1^\top + Y(\gamma^{-2}C_1^\top C_1 - C_2^\top C_2)Y = 0
    $$
    （在一些简化假设下，例如 `D21` 和 `B1` 正交）

3.  这两个解 `X∞` 和 `Y∞` 满足一个**耦合条件**：
    $$
    \rho(X_\infty Y_\infty) < \gamma^2
    $$
    其中 `ρ(·)` 表示矩阵的谱半径（最大特征值的绝对值）。

### 步骤 3: 控制器的构建

如果上述三个条件都满足，那么一个能使闭环系统稳定的 H∞ 次优控制器 `K(s)` 就可以被明确地构造出来。其状态空间形式 `K(s) = [Ak, Bk, Ck, Dk]` 的各项由 `P` 的矩阵和 Riccati 方程的解 `X∞`, `Y∞` 共同决定。

一个中心（central）控制器可以表示为：
$$
\begin{align*}
D_k &= \text{... (取决于 } D_{ij} \text{)} \\
C_k &= -B_2^\top X_\infty \\
B_k &= (I - \gamma^{-2}Y_\infty X_\infty)^{-1} Y_\infty C_2^\top \\
A_k &= A + \gamma^{-2}B_1 B_1^\top X_\infty + B_2 C_k + B_k C_2
\end{align*}
$$
*注意：这里的公式是简化形式，实际的公式更为复杂，并需要处理 `D` 矩阵的各种情况。*

### `hinfsyn` 的工作流程

`hinfsyn` 函数在内部执行的就是上述过程：

1.  **γ-迭代**: `hinfsyn` 实际上是在一个区间内搜索最小的 `γ` 值。它从一个 `γ` 的猜测值开始。
2.  **求解Riccati方程**: 对于当前的 `γ`，它尝试求解上述两个Riccati方程。如果方程无解或者解不满足半正定性，说明这个 `γ` 太小了，无法实现，需要增大 `γ` 再试。
3.  **检查耦合条件**: 如果Riccati方程有合适的解 `X∞` 和 `Y∞`，它会接着检查谱半径条件 `ρ(X∞ * Y∞) < γ^2`。如果不满足，同样说明 `γ` 太小。
4.  **二分搜索**: `hinfsyn` 使用高效的二分搜索算法来快速定位满足所有三个条件的最小 `γ` 值。
5.  **构建控制器**: 一旦找到最小的可行 `γ`（或一个足够接近的值），它就使用上面给出的公式来构建控制器 `K` 的状态空间矩阵，并将其作为结果返回。

**总结**：`hinfsyn` 并非使用通用的优化求解器，而是利用了H∞控制问题的特殊结构，将其转化为一个可以通过求解两组Riccati方程并进行谱半径检查来高效解决的问题。这个过程保证了计算的可靠性和效率。
